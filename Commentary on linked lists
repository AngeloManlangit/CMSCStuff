When I was younger and new to programming, I had heard about the concepts of Linked Lists early on and was afraid of facing that topic as I heard that it was complicated to implement. Now though, I still share the same sentiment but I understand how it works. Linked Lists are interesting to me because of its simplicity and dynamicity. The concept of nodes with pointers that point to other nodes are simple enough to understand. You just need to group data with a pointer, place them somewhere within the memory and let the nodes point to each other so that they are connected. My main issue though is usually during its implementation. Sometimes I get lost navigating the list since there is no specific index to keep track of everything, but that’s just part of what makes Linked Lists unique.

Linked Lists and Arrays serve the same purpose: store a bunch of data and connect them together under a list. However, the way they are used and made are vastly different. Both at a fundamental level make use of pointers, but the location of each element of data is what differs. For Arrays, they tend to be beside each other, hence why you can easily find a specific index as you can just find the location relative to the start of the pointer. Linked Lists do things differently though. Linked Lists’ elements can be anywhere and have any address, only connected by a different variable that points to another element. That is what makes Linked Lists unique, and much more fun to learn in my opinion. Although it is hard to implement and makes me a little scared of potential bugs, it is way more enjoyable to make than arrays, mostly because I like the feeling of having overcome a difficult challenge.

Another thing I like about Linked Lists is that a majority of the processes are O(1). It makes my efficiency-craving brain tingle. Removing and adding elements are simpler as well. Since the data can be anywhere in the memory, we can just add new elements by allocating some memory with the new data and use the pointers to point to that. Same thing with removing but deleting data. It’s so simple! No need for moving elements to the right or left anymore to make space for the new data. And there is no need for resizing the maximum capacity as Linked Lists can effectively be infinite (only limited by the space in the memory). The potential of Linked Lists are effectively limitless.

However, there are some things that make Linked Lists less effective than arrays. Traversal is the main issue for me as you need to iterate N amount of times to reach a specific node in the list, whereas Arrays can instantly return the index. This traversal time is a tradeoff for the efficiency Linked Lists provides for adding and removing, but I still think there should be a way to make it easily accessible. I was thinking of making an array of pointers that point to each node in the list so that its index within the Linked List is saved and easily accessible. However, this might come with some cons as well since it makes use of both arrays and linked lists. Not only will it require more memory, the pointer array needs to be resized again and again which defeats the purpose of Linked Lists’ dynamic storage. It might cause more harm than good, but there should be a way for Linked List to have an easier traversal system that doesn’t go through the list iteratively.

Overall, Linked Lists and Arrays, although basically doing the same thing, are used for different cases. Perhaps there would be a way for a list to have both the pros of linked lists and arrays without having as many cons as each, but that would require a large amount of creativity and understanding on the inner workings of machines to be able to make it. At that point, it would be the perfect list, but there is no such thing as perfect in reality. The best thing we can do at this point is to perfect Linked Lists and use it accordingly. Knowing the circumstances in which arrays or linked lists are needed. Maybe even vector lists can be used, although that’s just a glorified array. Regardless, Linked Lists are genuinely interesting to learn. It’s good for students as an introduction to the application of pointers and the use of memory in programming. So often do programmers take memory and efficiency for granted, mostly settling for less because “if it works, it works”. But there is so much more potential in trying to improve what already exists, to innovate and create. I feel like that is what Linked Lists supposedly represents. Memory is crucially important in all machinery and programming. Even in real life, space is important, but usable space is limited. The universe expands infinitely, but only a fraction of it has matter within it. So we must make use of all the space we have and find ways to make our lives easier, efficient, and effective by taking advantage of the space. This may not apply to computers as the memory a computer can hold is dependent on the hardware, but because of how large gigabytes are compared to bytes, we are a long way from worrying about running out of space. Still though, we need to be wary of how much memory we use because there is still the possibility of it running out, causing errors within the code. If memory were a country, then Linked Lists would be a road that connects different houses and buildings where each structure is pointing a path to the next one. In the end of the road is nothing (if the linked list is not circular). The country can only hold so many structures and things might get too clumped like a city if proper urban planning wasn’t considered. 
